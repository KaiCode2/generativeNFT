// SPDX-License-Identifier: UNLICENSED
// Author: Kai Aldag <kaialdag@icloud.com>
// Date: September 28, 2022
// Purpose: Make cool diamonds n shit

pragma solidity ^0.8.12;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "./utils/Base64.sol";

contract Diamonds is ERC721 {

    constructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) {

    }

    function mint(uint256 tokenID) external {
        _mint(msg.sender, tokenID);
    }

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");

        string memory name = string.concat("Diamond #", Strings.toString(tokenId));
        string memory description = "oooo such shine";
        // string memory image = generateBase64Image(tokenId);

        return string(
            abi.encodePacked(
                'data:application/json;base64,',
                Base64.encode(
                    bytes(
                        abi.encodePacked(
                            '{"name":"', 
                            name,
                            '", "description":"', 
                            description,
                            // '", "image": "', 
                            // 'data:image/svg+xml;base64,', 
                            // image,
                            '", "animation_url": "', // TODO: Convert animation URL to pure SVG
                            // 'data:text/html;base64,', 
                            // image,
                            'data:text/html;base64,PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImVuIiA+CjxoZWFkPgogIDxtZXRhIGNoYXJzZXQ9IlVURi04Ij4KICA8dGl0bGU+Q29kZVBlbiAtIEp1c3QgYSBCZWF1dHk8L3RpdGxlPgogIDxsaW5rIHJlbD0ic3R5bGVzaGVldCIgaHJlZj0iLi9zdHlsZS5jc3MiPgogIDxzdHlsZT4KICAgICogewogICAgYm94LXNpemluZzogYm9yZGVyLWJveDsKICB9CiAgCiAgaHRtbCwgYm9keSB7CiAgICBtYXJnaW46IDA7CiAgICBtaW4taGVpZ2h0OiAxMDB2aDsKICAgIG92ZXJmbG93OiBoaWRkZW47CiAgICAKICAgIGJhY2tncm91bmQ6CiAgICByZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50KAogICAgY2lyY2xlIGF0IGNlbnRlciwKICAgICAgIzQ0NCAwIDEwJSwKICAgICAgIzExMSAxMCUgMjAlCiAgICApOwogICAgCiAgICB0b3VjaC1hY3Rpb246IG5vbmU7CiAgfQogIAogIGNhbnZhcyB7CiAgICB3aWR0aDogMTAwJTsKICAgIGhlaWdodDogYXV0bzsKICAgIG9iamVjdC1maXQ6IGNvbnRhaW47CiAgfQogIDwvc3R5bGU+CjwvaGVhZD4KPGJvZHk+CjwhLS0gcGFydGlhbDppbmRleC5wYXJ0aWFsLmh0bWwgLS0+CjxjYW52YXMgaWQ9ImNhbnZhcyI+PC9jYW52YXM+CjwhLS0gcGFydGlhbCAtLT4KICA8c2NyaXB0PgogICAgY29uc3QgY2FudmFzID0gd2luZG93LmNhbnZhcwpjb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCJ3ZWJnbDIiKQpjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbwovKiogQHR5cGUge01hcDxzdHJpbmcsUG9pbnRlckV2ZW50Pn0gKi8KY29uc3QgdG91Y2hlcyA9IG5ldyBNYXAoKQoKY29uc3QgdmVydGV4U291cmNlID0gYCN2ZXJzaW9uIDMwMCBlcwojaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0gKcHJlY2lzaW9uIGhpZ2hwIGZsb2F0OwojZWxzZQpwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsKI2VuZGlmCgppbiB2ZWMyIHBvc2l0aW9uOwoKdm9pZCBtYWluKHZvaWQpIHsKICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMC4sIDEuKTsKfQpgCmNvbnN0IGZyYWdtZW50U291cmNlID0gYCN2ZXJzaW9uIDMwMCBlcwovKioqKioqKioqCiogbWFkZSBieSBNYXR0aGlhcyBIdXJybGUgKEBhdHplZGVudCkKKi8KCiNpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSApwcmVjaXNpb24gaGlnaHAgZmxvYXQ7CiNlbHNlCnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OwojZW5kaWYKCnVuaWZvcm0gdmVjMiByZXNvbHV0aW9uOwp1bmlmb3JtIGludCBwb2ludGVyQ291bnQ7CnVuaWZvcm0gdmVjMiB0b3VjaDsKdW5pZm9ybSBmbG9hdCB0aW1lOwoKY29uc3QgZmxvYXQgUEkgPSByYWRpYW5zKDE4MC4pOwpjb25zdCBmbG9hdCBUQVUgPSAyLipQSTsKY29uc3QgZmxvYXQgSU9SID0gMS40NTsKY29uc3QgZmxvYXQgREVOU0UgPSAuNzsKCiNkZWZpbmUgTUFYX1NURVBTIDEwMAojZGVmaW5lIE1BWF9ESVNUIDIwLgojZGVmaW5lIFNVUkZfRElTVCAuMDAxCgojZGVmaW5lIFMgc21vb3Roc3RlcAojZGVmaW5lIFQgMy41ICsgdGltZQoKb3V0IHZlYzQgZnJhZ0NvbG9yOwoKdmVjMiBNYXRNaW4odmVjMiBsaHMsIHZlYzIgcmhzKSB7CiAgaWYgKGxocy54IDwgcmhzLngpIHJldHVybiBsaHM7CgogIHJldHVybiByaHM7Cn0KCmZsb2F0IGNMZW5ndGgodmVjMiBwLCBmbG9hdCBrKSB7CiAgcCA9IGFicyhwKTsKCiAgcmV0dXJuIHBvdyhwb3cocC54LCBrKStwb3cocC55LCBrKSwgMS4vayk7Cn0KCm1hdDIgUm90KGZsb2F0IGEpIHsKICBmbG9hdCBzID0gc2luKGEpLAogIGMgPSBjb3MoYSk7CiAgcmV0dXJuIG1hdDIoYywgLXMsIHMsIGMpOwp9CgpmbG9hdCBTcGlyYWwodmVjMiBwLCBmbG9hdCB0LCBmbG9hdCBrKSB7CiAgZmxvYXQgciA9IGNMZW5ndGgocCwgayk7CiAgZmxvYXQgYSA9IGF0YW4ocC55LCBwLngpIC8gVEFVOwoKICByZXR1cm4gc2luKGZyYWN0KGxvZyhyKSAqIHQgKyBhKSk7Cn0KCmZsb2F0IE9jdGFoZWRyb24odmVjMyBwLCBmbG9hdCBzKSB7CiAgcCA9IGFicyhwKTsKCiAgcmV0dXJuIChwLnggKyBwLnkgKyBwLnogLSBzKSAqICgxLiAvIHNxcnQoMy4pKTsKfQoKdmVjMiBHZXREaXN0KHZlYzMgcCkgewogIHZlYzIgbWQgPSBNYXRNaW4oCiAgICB2ZWMyKAogICAgICBPY3RhaGVkcm9uKHAsIDEuKSwKICAgICAgMS4KICAgICksCiAgICB2ZWMyKAogICAgICBkb3QoCiAgICAgICAgcCwKICAgICAgICBub3JtYWxpemUodmVjMyguMCwgMS4sIC4wKSkKICAgICAgKSArIDIuLCAyLgogICAgKQogICk7CgogIHJldHVybiBtZDsKfQoKdmVjMiBSYXlNYXJjaCh2ZWMzIHJvLCB2ZWMzIHJkLCBmbG9hdCBzaWRlKSB7CiAgZmxvYXQgZE8gPSAwLjsKICB2ZWMyIGQ7CgogIGZvciAoaW50IGkgPSAwOyBpIDwgTUFYX1NURVBTOyBpKyspIHsKICAgIHZlYzMgcCA9IHJvICsgcmQqZE87CiAgICBkID0gR2V0RGlzdChwKSAqIHNpZGU7CiAgICBkTyArPSBkLng7CgogICAgaWYgKGRPID4gTUFYX0RJU1QgfHwgYWJzKGQueCkgPCBTVVJGX0RJU1QpIGJyZWFrOwogIH0KCiAgcmV0dXJuIHZlYzIoZE8sIGQueSk7Cn0KCnZlYzMgR2V0Tm9ybWFsKHZlYzMgcCkgewogIGZsb2F0IGQgPSBHZXREaXN0KHApLng7CiAgdmVjMiBlID0gdmVjMiguMDUsIDApOwoKICB2ZWMzIG4gPSBkIC0gdmVjMygKICAgIEdldERpc3QocC1lLnh5eSkueCwKICAgIEdldERpc3QocC1lLnl4eSkueCwKICAgIEdldERpc3QocC1lLnl5eCkueCk7CgogIHJldHVybiBub3JtYWxpemUobik7Cn0KCnZlYzMgR2V0UmF5RGlyKHZlYzIgdXYsIHZlYzMgcCwgdmVjMyBsLCBmbG9hdCB6KSB7CiAgdmVjMyBmID0gbm9ybWFsaXplKGwtcCksCiAgciA9IG5vcm1hbGl6ZShjcm9zcyh2ZWMzKDAsIDEsIDApLCBmKSksCiAgdSA9IGNyb3NzKGYsIHIpLAogIGMgPSBmKnosCiAgaSA9IGMgKyB1di54KnIgKyB1di55KnUsCiAgZCA9IG5vcm1hbGl6ZShpKTsKICByZXR1cm4gZDsKfQoKdmVjMyBSZWZyYWN0KHZlYzMgcCwgdmVjMyBuLCBpbm91dCB2ZWMzIHJvLCBpbm91dCB2ZWMzIHJkLCBpbm91dCBmbG9hdCBvZCkgewogIHZlYzMgcmRJbiA9IHJlZnJhY3QocmQsIG4sIDEuL0lPUik7CiAgdmVjMyBwRW50ZXIgPSBwLW4qU1VSRl9ESVNUKjMuOwogIHZlYzIgZEluID0gUmF5TWFyY2gocEVudGVyLCByZEluLCAtMS4pOwogIHZlYzMgcEV4aXQgPSBwRW50ZXIgKyByZEluICogZEluLng7CiAgdmVjMyBuRXhpdCA9IC1HZXROb3JtYWwocEV4aXQpOwogIHZlYzMgcmRPdXQgPSByZWZyYWN0KHJkSW4sIG5FeGl0LCBJT1IpOwoKICBpZiAoZG90KHJkT3V0LCByZE91dCkgPT0gLjApIHsKICAgIHJkT3V0ID0gcmVmbGVjdChyZEluLCBuRXhpdCk7CiAgfQoKICBybyA9IHBFbnRlcjsKICByZCA9IHJkT3V0OwogIG9kID0gZXhwKC1kSW4ueCAqIERFTlNFKTsKCiAgcmV0dXJuIHBFeGl0Owp9Cgp2ZWMzIFJlbmRlcihpbm91dCB2ZWMzIHJvLCBpbm91dCB2ZWMzIHJkLCBpbm91dCBmbG9hdCByZWYpIHsKICB2ZWMyIGQgPSBSYXlNYXJjaChybywgcmQsIDEuKTsKCiAgdmVjMyBjb2wgPSB2ZWMzKC4wKTsKCiAgaWYgKGQueCA8IE1BWF9ESVNUKSB7CiAgICB2ZWMzIHAgPSBybyArIHJkICogZC54OwogICAgdmVjMyBsID0gbm9ybWFsaXplKHJvKTsKICAgIHZlYzMgbiA9IEdldE5vcm1hbChwKTsKICAgIHZlYzMgciA9IHJlZmxlY3QocmQsIG4pOwoKICAgIC8vIG1hdGVyaWFsCiAgICB2ZWMzIG1hdCA9IHZlYzMoLjApOwogICAgZmxvYXQgZnJlcyA9IHBvdyhjbGFtcCgxLitkb3QobiwgcmQpLCAuMCwgMS4pLCA1Lik7CgoJCXZlYzMgb2ZmcyA9IHZlYzMoLjI1KSpsZW5ndGgocC54eik7CiAgICBmbG9hdCBzID0gMS41ICogc2luKFQqLjUpOwogICAgZmxvYXQgayA9IC41ICsgMS4gKiAoLjUrLjUqY29zKFQqLjUpKTsKICAgIG1hdDIgcm90ID0gUm90KFQqLjUpOwoKICAgIC8vIGZsb29yCiAgICBpZiAoZC55ID09IDIuKSB7CgogICAgICBmbG9hdCBzcGlyYWwgPSBjbGFtcCgKICAgICAgICBTcGlyYWwocC54eipyb3QsIHMsIGspLAogICAgICAgIC4wLAogICAgICAgIDEuCiAgICAgICk7CgogICAgICBtYXQgPSBwb3codmVjMyhzcGlyYWwpIC0gb2ZmcywgdmVjMyhvZmZzKSk7CgogICAgICBybyA9IHAgKyBuICogU1VSRl9ESVNUICogMy47CiAgICAgIHJkID0gcjsKCiAgICB9CiAgICAvLyBvYmplY3QKICAgIGVsc2UgaWYgKGQueSA9PSAxLikgewoKICAgICAgZmxvYXQgb2Q7CiAgICAgIHZlYzMgc3QgPSBSZWZyYWN0KHAsIG4sIHJvLCByZCwgb2QpOwogICAgICBmbG9hdCBzcGlyYWwgPSBTcGlyYWwoc3QueHoqcm90LCBzLCBrKTsKICAgICAgCiAgICAgIHZlYzMgc2kgPSBwb3codmVjMyhzcGlyYWwpIC0gb2ZmcywgdmVjMyhvZmZzKSk7CgogICAgICBtYXQgPSBtaXgoCiAgICAgICAgc2ksCiAgICAgICAgdmVjMygxLjUsIDEuNzUsIDIuKSwKICAgICAgICBvZAogICAgICApIC0gcG93KDEuLWFicyhyby55KSwgMi4pOwogICAgICBtYXQgKj0gZXhwKGxvZyh2ZWMzKC41KSkpOwoKICAgICAgcmVmID0gbWl4KC4wNSwgLjUsIGZyZXMpOwogICAgfQoKICAgIC8vIGxpZ2h0CiAgICBmbG9hdCBkaWZmdXNlID0gZG90KG4sIGwpICogLjUgKyAuNTsKICAKICAgIGZsb2F0IHNwb3QgPSBjbGFtcCgKICAgICAgZG90KAogICAgICAgIG5vcm1hbGl6ZShyKSwKICAgICAgICByZWZsZWN0KHIsIHZlYzMoMCkpKSwKICAgICAgLjAsCiAgICAgIDEuCiAgICApOwogIAogICAgY29sICs9IC44ICogZGlmZnVzZTsKICAgIGNvbCArPSAuOTUgKiBwb3coc3BvdCwgMTYuKTsKICAKICAgIGNvbCAqPSBtYXQ7CiAgfQoKICByZXR1cm4gY29sOwp9Cgp2b2lkIG1haW4odm9pZCkgewogIGZsb2F0IG1uID0gbWluKHJlc29sdXRpb24ueCwgcmVzb2x1dGlvbi55KTsKICBmbG9hdCBteCA9IG1heChyZXNvbHV0aW9uLngsIHJlc29sdXRpb24ueSk7CiAgdmVjMiB1diA9ICgKICAgIGdsX0ZyYWdDb29yZC54eSAtIC41ICogcmVzb2x1dGlvbi54eQogICkgLyBteDsKCiAgdmVjMiBtID0gdG91Y2gueHkgLyByZXNvbHV0aW9uLnh5OwogIG0ueSA9IGNsYW1wKG0ueSwgLjAsIC41NSk7CgogIHZlYzMgcm8gPSB2ZWMzKDAuLCAzLiwgLTYuKTsKICBib29sIGF1dCA9IHBvaW50ZXJDb3VudCA9PSAwOwoKICByby55eiAqPSBSb3QoYXV0ID8gLjU1K3NpbihUKi4yNSkqLjU6IC1tLnkgKiBQSSArIDEuKTsKICByby54eiAqPSBSb3QoYXV0ID8gVCouMjU6IC1tLnggKiBUQVUpOwoKICB2ZWMzIHJkID0gR2V0UmF5RGlyKHV2LCBybywgdmVjMygwKSwgMS4pOwogIHZlYzMgc3RvID0gcm87CgogIGZsb2F0IHJlZiA9IC4wOwogIHZlYzMgY29sID0gUmVuZGVyKHJvLCByZCwgcmVmKTsKCiAgZm9yIChpbnQgaSA9IDA7IGkgPCAyOyBpKyspIHsKICAgIGNvbCArPSByZWYgKiBSZW5kZXIocm8sIHJkLCByZWYpOwogIH0KCiAgLy8gZ2FtbWEgY29ycmVjdGlvbgogIGNvbCA9IHBvdyhjb2wsIHZlYzMoLjQ1KSk7CgogIC8vIHZpZ25ldHRlCiAgdmVjMiB6ID0gKGdsX0ZyYWdDb29yZC54eSAtLjUgKiByZXNvbHV0aW9uKSAvIG1uOwogIGNvbCAqPSAxLiAtIGRvdCh6LCB6KTsKCiAgZnJhZ0NvbG9yID0gdmVjNChjb2wsIDEuKTsKfQpgCmxldCB0aW1lCmxldCBidWZmZXIKbGV0IHByb2dyYW0KbGV0IHRvdWNoCmxldCByZXNvbHV0aW9uCmxldCBwb2ludGVyQ291bnQKbGV0IHZlcnRpY2VzID0gW10KbGV0IHRvdWNoaW5nID0gZmFsc2UKCmZ1bmN0aW9uIHJlc2l6ZSgpIHsKICBjb25zdCB7IGlubmVyV2lkdGg6IHdpZHRoLCBpbm5lckhlaWdodDogaGVpZ2h0IH0gPSB3aW5kb3cKCiAgY2FudmFzLndpZHRoID0gd2lkdGggKiBkcHIKICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogZHByCgogIGdsLnZpZXdwb3J0KDAsIDAsIHdpZHRoICogZHByLCBoZWlnaHQgKiBkcHIpCn0KCmZ1bmN0aW9uIGNvbXBpbGUoc2hhZGVyLCBzb3VyY2UpIHsKICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpCiAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpCgogIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7CiAgICBjb25zb2xlLmVycm9yKGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSkKICB9Cn0KCmZ1bmN0aW9uIHNldHVwKCkgewogIGNvbnN0IHZzID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpCiAgY29uc3QgZnMgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKQoKICBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpCgogIGNvbXBpbGUodnMsIHZlcnRleFNvdXJjZSkKICBjb21waWxlKGZzLCBmcmFnbWVudFNvdXJjZSkKCiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZzKQogIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcykKICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKQoKICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7CiAgICBjb25zb2xlLmVycm9yKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKQogIH0KCiAgdmVydGljZXMgPSBbLTEuMCwgLTEuMCwgMS4wLCAtMS4wLCAtMS4wLCAxLjAsIC0xLjAsIDEuMCwgMS4wLCAtMS4wLCAxLjAsIDEuMF0KCiAgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCkKCiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcikKICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcyksIGdsLlNUQVRJQ19EUkFXKQoKICBjb25zdCBwb3NpdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICJwb3NpdGlvbiIpCgogIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uKQogIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCkKCiAgdGltZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAidGltZSIpCiAgdG91Y2ggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgInRvdWNoIikKICBwb2ludGVyQ291bnQgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgInBvaW50ZXJDb3VudCIpCiAgcmVzb2x1dGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAicmVzb2x1dGlvbiIpCn0KCmZ1bmN0aW9uIGRyYXcobm93KSB7CiAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAxKQogIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpCgogIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSkKICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKQoKICBnbC51bmlmb3JtMWYodGltZSwgbm93ICogMC4wMDEpCiAgZ2wudW5pZm9ybTJmKHRvdWNoLCAuLi5nZXRUb3VjaGVzKCkpCiAgZ2wudW5pZm9ybTFpKHBvaW50ZXJDb3VudCwgdG91Y2hlcy5zaXplKQogIGdsLnVuaWZvcm0yZihyZXNvbHV0aW9uLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpCiAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIHZlcnRpY2VzLmxlbmd0aCAqIDAuNSkKfQoKZnVuY3Rpb24gZ2V0VG91Y2hlcygpIHsKICBpZiAoIXRvdWNoZXMuc2l6ZSkgewogICAgcmV0dXJuIFswLCAwXQogIH0KCiAgZm9yIChsZXQgW2lkLCB0XSBvZiB0b3VjaGVzKSB7CiAgICBjb25zdCByZXN1bHQgPSBbZHByICogdC5jbGllbnRYLCBkcHIgKiAoaW5uZXJIZWlnaHQgLSB0LmNsaWVudFkpXQoKICAgIHJldHVybiByZXN1bHQKICB9Cn0KCmZ1bmN0aW9uIGxvb3Aobm93KSB7CiAgZHJhdyhub3cpCiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApCn0KCmZ1bmN0aW9uIGluaXQoKSB7CiAgc2V0dXAoKQogIHJlc2l6ZSgpCiAgbG9vcCgwKQp9Cgpkb2N1bWVudC5ib2R5Lm9ubG9hZCA9IGluaXQKd2luZG93Lm9ucmVzaXplID0gcmVzaXplIApjYW52YXMub25wb2ludGVyZG93biA9IGUgPT4gewogIHRvdWNoaW5nID0gdHJ1ZQogIHRvdWNoZXMuc2V0KGUucG9pbnRlcklkLCBlKQp9CmNhbnZhcy5vbnBvaW50ZXJtb3ZlID0gZSA9PiB7CiAgaWYgKCF0b3VjaGluZykgcmV0dXJuCiAgdG91Y2hlcy5zZXQoZS5wb2ludGVySWQsIGUpCn0KY2FudmFzLm9ucG9pbnRlcnVwID0gZSA9PiB7CiAgdG91Y2hpbmcgPSBmYWxzZQogIHRvdWNoZXMuY2xlYXIoKQp9CmNhbnZhcy5vbnBvaW50ZXJvdXQgPSBlID0+IHsKICB0b3VjaGluZyA9IGZhbHNlCiAgdG91Y2hlcy5jbGVhcigpCn0KICA8L3NjcmlwdD4KCjwvYm9keT4KPC9odG1sPgo='
                            '", "background_color": "', // TODO: Set to hue!
                            "003d3d"
                            '", "attributes": [',
                                // '{"trait_type": "Blend Mode", "value": "', blendModeString(tokenTraits.blendMode), '"},'
                                // '{"display_type": "number", "trait_type": "Duration", "value": "', Strings.toString(tokenTraits.duration), '"}' // QUESTION: add hue as trait?
                            ']}'
                        )
                    )
                )
            )
        );
    }

//     function generateBase64Image(uint256 tokenId) public view returns (string memory) {
//         return Base64.encode(bytes(generateImage(tokenId)));
//     }

//     function generateImage(uint256 tokenId) public pure returns (string memory) {

//         return string(
//             abi.encodePacked(
// '<!doctype html><html lang=en><meta charset=UTF-8><style>*{box-sizing:border-box}body,html{margin:0;min-height:100vh;overflow:hidden;background:repeating-radial-gradient(circle at center,#444 0 10%,#111 10% 20%);touch-action:none}canvas{width:100%;height:auto;object-fit:contain}</style><canvas id=canvas></canvas><script>const canvas=window.canvas,gl=canvas.getContext("webgl2"),dpr=window.devicePixelRatio,touches=new Map,vertexSource="#version 300 es\n   #ifdef GL_FRAGMENT_PRECISION_HIGH\n   precision highp float;\n   #else\n   precision mediump float;\n   #endif\n   \n   in vec2 position;\n   \n   void main(void) {\n       gl_Position = vec4(position, 0., 1.);\n   }\n   ",fragmentSource="#version 300 es\n   /*********\n   * made by Matthias Hurrle (@atzedent)\n   */\n   \n   #ifdef GL_FRAGMENT_PRECISION_HIGH\n   precision highp float;\n   #else\n   precision mediump float;\n   #endif\n   \n   uniform vec2 resolution;\n   uniform int pointerCount;\n   uniform vec2 touch;\n   uniform float time;\n   \n   const float PI = radians(180.);\n   const float TAU = 2.*PI;\n   const float IOR = 1.45;\n   const float DENSE = .7;\n   \n   #define MAX_STEPS 100\n   #define MAX_DIST 20.\n   #define SURF_DIST .001\n   \n   #define S smoothstep\n   #define T 3.5 + time\n   \n   out vec4 fragColor;\n   \n   vec2 MatMin(vec2 lhs, vec2 rhs) {\n     if (lhs.x < rhs.x) return lhs;\n   \n     return rhs;\n   }\n   \n   float cLength(vec2 p, float k) {\n     p = abs(p);\n   \n     return pow(pow(p.x, k)+pow(p.y, k), 1./k);\n   }\n   \n   mat2 Rot(float a) {\n     float s = sin(a),\n     c = cos(a);\n     return mat2(c, -s, s, c);\n   }\n   \n   float Spiral(vec2 p, float t, float k) {\n     float r = cLength(p, k);\n     float a = atan(p.y, p.x) / TAU;\n   \n     return sin(fract(log(r) * t + a));\n   }\n   \n   float Octahedron(vec3 p, float s) {\n     p = abs(p);\n   \n     return (p.x + p.y + p.z - s) * (1. / sqrt(3.));\n   }\n   \n   vec2 GetDist(vec3 p) {\n     vec2 md = MatMin(\n       vec2(\n         Octahedron(p, 1.),\n         1.\n       ),\n       vec2(\n         dot(\n           p,\n           normalize(vec3(.0, 1., .0))\n         ) + 2., 2.\n       )\n     );\n   \n     return md;\n   }\n   \n   vec2 RayMarch(vec3 ro, vec3 rd, float side) {\n     float dO = 0.;\n     vec2 d;\n   \n     for (int i = 0; i < MAX_STEPS; i++) {\n       vec3 p = ro + rd*dO;\n       d = GetDist(p) * side;\n       dO += d.x;\n   \n       if (dO > MAX_DIST || abs(d.x) < SURF_DIST) break;\n     }\n   \n     return vec2(dO, d.y);\n   }\n   \n   vec3 GetNormal(vec3 p) {\n     float d = GetDist(p).x;\n     vec2 e = vec2(.05, 0);\n   \n     vec3 n = d - vec3(\n       GetDist(p-e.xyy).x,\n       GetDist(p-e.yxy).x,\n       GetDist(p-e.yyx).x);\n   \n     return normalize(n);\n   }\n   \n   vec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n     vec3 f = normalize(l-p),\n     r = normalize(cross(vec3(0, 1, 0), f)),\n     u = cross(f, r),\n     c = f*z,\n     i = c + uv.x*r + uv.y*u,\n     d = normalize(i);\n     return d;\n   }\n   \n   vec3 Refract(vec3 p, vec3 n, inout vec3 ro, inout vec3 rd, inout float od) {\n     vec3 rdIn = refract(rd, n, 1./IOR);\n     vec3 pEnter = p-n*SURF_DIST*3.;\n     vec2 dIn = RayMarch(pEnter, rdIn, -1.);\n     vec3 pExit = pEnter + rdIn * dIn.x;\n     vec3 nExit = -GetNormal(pExit);\n     vec3 rdOut = refract(rdIn, nExit, IOR);\n   \n     if (dot(rdOut, rdOut) == .0) {\n       rdOut = reflect(rdIn, nExit);\n     }\n   \n     ro = pEnter;\n     rd = rdOut;\n     od = exp(-dIn.x * DENSE);\n   \n     return pExit;\n   }\n   \n   vec3 Render(inout vec3 ro, inout vec3 rd, inout float ref) {\n     vec2 d = RayMarch(ro, rd, 1.);\n   \n     vec3 col = vec3(.0);\n   \n     if (d.x < MAX_DIST) {\n       vec3 p = ro + rd * d.x;\n       vec3 l = normalize(ro);\n       vec3 n = GetNormal(p);\n       vec3 r = reflect(rd, n);\n   \n       // material\n       vec3 mat = vec3(.0);\n       float fres = pow(clamp(1.+dot(n, rd), .0, 1.), 5.);\n   \n           vec3 offs = vec3(.25)*length(p.xz);\n       float s = 1.5 * sin(T*.5);\n       float k = .5 + 1. * (.5+.5*cos(T*.5));\n       mat2 rot = Rot(T*.5);\n   \n       // floor\n       if (d.y == 2.) {\n   \n         float spiral = clamp(\n           Spiral(p.xz*rot, s, k),\n           .0,\n           1.\n         );\n   \n         mat = pow(vec3(spiral) - offs, vec3(offs));\n   \n         ro = p + n * SURF_DIST * 3.;\n         rd = r;\n   \n       }\n       // object\n       else if (d.y == 1.) {\n   \n         float od;\n         vec3 st = Refract(p, n, ro, rd, od);\n         float spiral = Spiral(st.xz*rot, s, k);\n         \n         vec3 si = pow(vec3(spiral) - offs, vec3(offs));\n   \n         mat = mix(\n           si,\n           vec3(1.5, 1.75, 2.),\n           od\n         ) - pow(1.-abs(ro.y), 2.);\n         mat *= exp(log(vec3(.5)));\n   \n         ref = mix(.05, .5, fres);\n       }\n   \n       // light\n       float diffuse = dot(n, l) * .5 + .5;\n     \n       float spot = clamp(\n         dot(\n           normalize(r),\n           reflect(r, vec3(0))),\n         .0,\n         1.\n       );\n     \n       col += .8 * diffuse;\n       col += .95 * pow(spot, 16.);\n     \n       col *= mat;\n     }\n   \n     return col;\n   }\n   \n   void main(void) {\n     float mn = min(resolution.x, resolution.y);\n     float mx = max(resolution.x, resolution.y);\n     vec2 uv = (\n       gl_FragCoord.xy - .5 * resolution.xy\n     ) / mx;\n   \n     vec2 m = touch.xy / resolution.xy;\n     m.y = clamp(m.y, .0, .55);\n   \n     vec3 ro = vec3(0., 3., -6.);\n     bool aut = pointerCount == 0;\n   \n     ro.yz *= Rot(aut ? .55+sin(T*.25)*.5: -m.y * PI + 1.);\n     ro.xz *= Rot(aut ? T*.25: -m.x * TAU);\n   \n     vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n     vec3 sto = ro;\n   \n     float ref = .0;\n     vec3 col = Render(ro, rd, ref);\n   \n     for (int i = 0; i < 2; i++) {\n       col += ref * Render(ro, rd, ref);\n     }\n   \n     // gamma correction\n     col = pow(col, vec3(.45));\n   \n     // vignette\n     vec2 z = (gl_FragCoord.xy -.5 * resolution) / mn;\n     col *= 1. - dot(z, z);\n   \n     fragColor = vec4(col, 1.);\n   }\n   ";let time,buffer,program,touch,resolution,pointerCount,vertices=[],touching=!1;function resize(){const{innerWidth:n,innerHeight:e}=window;canvas.width=n*dpr,canvas.height=e*dpr,gl.viewport(0,0,n*dpr,e*dpr)}function compile(n,e){gl.shaderSource(n,e),gl.compileShader(n),gl.getShaderParameter(n,gl.COMPILE_STATUS)||console.error(gl.getShaderInfoLog(n))}function setup(){const n=gl.createShader(gl.VERTEX_SHADER),e=gl.createShader(gl.FRAGMENT_SHADER);program=gl.createProgram(),compile(n,vertexSource),compile(e,fragmentSource),gl.attachShader(program,n),gl.attachShader(program,e),gl.linkProgram(program),gl.getProgramParameter(program,gl.LINK_STATUS)||console.error(gl.getProgramInfoLog(program)),vertices=[-1,-1,1,-1,-1,1,-1,1,1,-1,1,1],buffer=gl.createBuffer(),gl.bindBuffer(gl.ARRAY_BUFFER,buffer),gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);const o=gl.getAttribLocation(program,"position");gl.enableVertexAttribArray(o),gl.vertexAttribPointer(o,2,gl.FLOAT,!1,0,0),time=gl.getUniformLocation(program,"time"),touch=gl.getUniformLocation(program,"touch"),pointerCount=gl.getUniformLocation(program,"pointerCount"),resolution=gl.getUniformLocation(program,"resolution")}function draw(n){gl.clearColor(0,0,0,1),gl.clear(gl.COLOR_BUFFER_BIT),gl.useProgram(program),gl.bindBuffer(gl.ARRAY_BUFFER,buffer),gl.uniform1f(time,.001*n),gl.uniform2f(touch,...getTouches()),gl.uniform1i(pointerCount,touches.size),gl.uniform2f(resolution,canvas.width,canvas.height),gl.drawArrays(gl.TRIANGLES,0,.5*vertices.length)}function getTouches(){if(!touches.size)return[0,0];for(let[n,e]of touches){return[dpr*e.clientX,dpr*(innerHeight-e.clientY)]}}function loop(n){draw(n),requestAnimationFrame(loop)}function init(){setup(),resize(),loop(0)}document.body.onload=init,window.onresize=resize,canvas.onpointerdown=n=>{touching=!0,touches.set(n.pointerId,n)},canvas.onpointermove=n=>{touching&&touches.set(n.pointerId,n)},canvas.onpointerup=n=>{touching=!1,touches.clear()},canvas.onpointerout=n=>{touching=!1,touches.clear()}</script></html>'
//             )
//         );
//     }
}
